/**
 * @file        044-ManagedListEntityAnswercodeScript.js
 * @description decides whether the “Answer Code” field (ktr_answercode) should be editable for a given user and record, based on:
    the user’s security role,
    the Managed List’s source type (Question Bank or Custom),
    whether the item is linked to an approved Study, and
    a parent-level “editable” flag
 *
 * @date        2026-01-19
 * @version     1.1
 *
 * @usage       Used on form of Managed list entity
 * @notes       
 */

var Ktr = Ktr || {};
Ktr.ManagedListEntity = Ktr.ManagedListEntity || {};

/**
 * Main orchestrator function - determines if Answer Text should be editable
 * Called on form load (Managed List lookup is set at creation and doesn't change)
 * @param {Object} executionContext execution context from form
 * @param {string} userRoleType user role type
 * @param {string} parentSourceType parent source type
 * @returns
 */
Ktr.ManagedListEntity.SetAnswerTextEditability = async function (
  executionContext,
  userRoleType,
  parentSourceType
) {
  try {
    console.log(
      `[SetAnswerTextEditability] Evaluating editability for Source Type: ${parentSourceType}, User Role: ${userRoleType}`
    );
    var formContext = executionContext.getFormContext();
    var answerTextField = formContext.getControl("ktr_answertextvalue");

    if (!answerTextField) {
      console.warn("Answer Text field (ktr_answertextvalue) not found on form");
      return;
    }

    if (!parentSourceType) {
      console.warn(
        "Could not determine parent source type - defaulting to read-only"
      );
      answerTextField.setDisabled(true);
      return;
    }

    var canEdit = await Ktr.ManagedListEntity.DetermineAnswerTextEditability(
      parentSourceType,
      userRoleType
    );

    // Apply the editability to the field
    answerTextField.setDisabled(!canEdit);

    // Log for debugging
    console.log(
      `[Answer Text Editability] Result: ${
        canEdit ? "EDITABLE" : "READ-ONLY"
      } | Source Type: ${parentSourceType} | User Role: ${userRoleType}`
    );
  } catch (error) {
    console.error("Error in SetAnswerTextEditability:", error);
    // Fail-safe: Block editing on any error
    try {
      var formContext = executionContext.getFormContext();
      var answerTextField = formContext.getControl("ktr_answertext");
      if (answerTextField) {
        answerTextField.setDisabled(true);
      }
    } catch (innerError) {
      console.error("Error in answerText fail-safe handler:", innerError);
    }
  }
};

/**
 * Main orchestrator function - determines if Answer Code should be editable
 * Called on form load (Managed List lookup is set at creation and doesn't change)
 * @param {Object} executionContext execution context from form
 * @param {string} userRoleType user role type
 * @param {string} parentSourceType parent source type
 * @returns
 */
Ktr.ManagedListEntity.SetAnswerCodeEditability = async function (
  executionContext,
  userRoleType,
  parentSourceType
) {
  try {
    console.log(
      `[SetAnswerCodeEditability] Evaluating editability for Source Type: ${parentSourceType}, User Role: ${userRoleType}`
    );
    var formContext = executionContext.getFormContext();
    var answerCodeField = formContext.getControl("ktr_answercode");

    if (!answerCodeField) {
      console.warn("Answer Code field (ktr_answercode) not found on form");
      return;
    }

    if (!parentSourceType) {
      console.warn(
        "Could not determine parent source type - defaulting to read-only"
      );
      answerCodeField.setDisabled(true);
      return;
    }

    // Determine editability based on complete business rules including user role
    var canEdit = await Ktr.ManagedListEntity.DetermineAnswerCodeEditability(
      formContext,
      parentSourceType,
      userRoleType
    );

    // Apply the editability to the field
    answerCodeField.setDisabled(!canEdit);

    // Log for debugging
    console.log(
      `[Answer Code Editability] Result: ${
        canEdit ? "EDITABLE" : "READ-ONLY"
      } | Source Type: ${parentSourceType} | User Role: ${userRoleType}`
    );
  } catch (error) {
    console.error("Error in SetAnswerCodeEditability:", error);
    // Fail-safe: Block editing on any error
    try {
      var formContext = executionContext.getFormContext();
      var answerCodeField = formContext.getControl("ktr_answercode");
      if (answerCodeField) {
        answerCodeField.setDisabled(true);
      }
    } catch (innerError) {
      console.error("Error in answerCode fail-safe handler:", innerError);
    }
  }
};

/**
 * Determine user's role type from security roles
 * @returns {String} - "Scripter", "CSUser", or "Unknown"
 */
Ktr.ManagedListEntity.GetUserRoleType = function () {
  try {
    var userRoles = Xrm.Utility.getGlobalContext().userSettings.roles;

    var isScripter = false;
    var isCSUser = false;
    var isSysAdmin = false;

    // Check each role the user has
    userRoles.forEach(function (role) {
      var roleName = role.name;

      if (roleName === "Kantar – Scripter") {
        isScripter = true;
      }
      if (roleName === "Kantar – Client Service User") {
        isCSUser = true;
      }
      if (roleName === "System Administrator") {
        isSysAdmin = true;
      }
    });

    // Log all detected roles for debugging
    console.log(
      `[Role Detection] Scripter: ${isScripter}, CS User: ${isCSUser}, Librarian: ${isSysAdmin}`
    );

    // Priority: Scripter has most permissive access
    if (isScripter) {
      return "Scripter";
    }

    // CS User have same access level
    if (isCSUser) {
      return "CSUser";
    }

    if (isSysAdmin) {
      return "SystemAdministrator";
    }

    // Unknown role - default to most restrictive
    console.warn("User does not have Scripter or CS User role");
    return "Unknown";
  } catch (error) {
    console.error("Error determining user role:", error);
    return "Unknown";
  }
};

/**
 * Core business logic - determines editability based on flowchart rules and user role
 * @param {Object} formContext - Form context
 * @param {String} parentSourceType - "Question Bank" or "Custom"
 * @param {String} userRoleType - "Scripter", "CSUser", or "Unknown"
 * @returns {Boolean} - True if editable, false if read-only
 */
Ktr.ManagedListEntity.DetermineAnswerCodeEditability = async function (
  formContext,
  parentSourceType,
  userRoleType
) {
  var everInSnapshot =
    await Ktr.ManagedListEntity.IsEverInSnapshot(formContext);
  console.log(`Ever in snapshot flag: ${everInSnapshot}`);
  var isParentEditable =
    await Ktr.ManagedListEntity.IsParentRecordEditable(formContext);
  console.log(`Parent editability flag: ${isParentEditable}`);
  switch (parentSourceType) {
    case "Question Bank":
      if (userRoleType === "Scripter") {
        // Scripter can edit without checking parent toggle
        if (!everInSnapshot) {
          console.log(
            "[Editability Check] Question Bank source Draft - Scripter role - BLOCKED - its unavailable for scripters"
          );
          return false;
        }
        console.log(
          "[Editability Check]  Question Bank source - Scripter role - ALLOWED (bypass parent toggle)"
        );
        return true;
      } else if (userRoleType === "CSUser") {
        console.log(
          `[Editability Check] Question Bank source  CS User - Ever in snapshot flag: ${everInSnapshot} - Parent editability flag: ${isParentEditable}`
        );
        return isParentEditable && !everInSnapshot;
      } else if (userRoleType === "SystemAdministrator") {
        // SystemAdministrator can edit without checking parent toggle
        console.log(
          "[Editability Check] Question Bank source SystemAdministrator role - ALLOWED (bypass parent toggle)"
        );
        return true;
      } else {
        // Unknown role - default to blocked for safety
        console.log(
          "[Editability Check] Unknown role for Question Bank - BLOCKED by default for safety"
        );
        return false;
      }
    case "Custom":
      if (userRoleType === "Scripter") {
        if (!everInSnapshot) {
          console.log(
            "[Editability Check] Custom source Draft - Scripter role - BLOCKED - its unavailable for scripters"
          );
          return false;
        }
        // Scripter can edit without checking parent toggle
        console.log(
          "[Editability Check] Custom source Scripter role - ALLOWED (bypass parent toggle)"
        );
        return true;
      } else if (userRoleType === "CSUser") {
        console.log(
          `[Editability Check] Custom source  CS User - Ever in snapshot flag: ${everInSnapshot} - Parent editability flag: ${isParentEditable}`
        );
        if (everInSnapshot) {
          console.log(
            "[Editability Check] Custom source CS User - BLOCKED - ever in snapshot"
          );
          return false;
        }
        // CS User/Librarian must check parent editability flag
        return isParentEditable && !everInSnapshot;
      } else if (userRoleType === "SystemAdministrator") {
        // SystemAdministrator can edit without checking parent toggle
        console.log(
          "[Editability Check] SystemAdministrator role - ALLOWED (bypass parent toggle)"
        );
        return true;
      } else {
        // Unknown role - default to blocked for safety
        console.log(
          "[Editability Check] Unknown role - BLOCKED by default for safety"
        );
        return false;
      }

    default:
      console.warn(
        `[Editability Check] Unknown source type: ${parentSourceType} - BLOCKED by default`
      );
      return false;
  }
};

/**
 * Core business logic - determines editability based on flowchart rules and user role
 * @param {string} parentSourceType
 * @param {string} userRoleType
 * @returns boolean - True if editable, false if read-only
 */
Ktr.ManagedListEntity.DetermineAnswerTextEditability = async function (
  parentSourceType,
  userRoleType
) {
  switch (parentSourceType) {
    case "Question Bank":
      if (userRoleType === "Scripter") {
        console.log(
          `[AnswerText Editability Check] Question Bank source Scripter - BLOCKED`
        );
        return false;
      } else if (userRoleType === "CSUser") {
        console.log(
          `[AnswerText Editability Check] Question Bank source CS User - ALLOWED`
        );
        return true;
      } else if (userRoleType === "SystemAdministrator") {
        console.log(
          "[AnswerText Editability Check] Question Bank source SystemAdministrator role - ALLOWED"
        );
        return true;
      } else {
        // Unknown role - default to blocked for safety
        console.log(
          "[AnswerText Editability Check] Unknown role for Question Bank - BLOCKED by default for safety"
        );
        return false;
      }
    case "Custom":
      if (userRoleType === "Scripter") {
        console.log(
          `[AnswerText Editability Check] Custom source Scripter - BLOCKED`
        );
        return false;
      } else if (userRoleType === "CSUser") {
        console.log(
          `[AnswerText Editability Check] Custom source CS User - ALLOWED`
        );
        return true;
      } else if (userRoleType === "SystemAdministrator") {
        console.log(
          "[AnswerText Editability Check] Custom source SystemAdministrator role - ALLOWED"
        );
        return true;
      } else {
        // Unknown role - default to blocked for safety
        console.log(
          "[AnswerText Editability Check] Unknown role - BLOCKED by default for safety"
        );
        return false;
      }

    default:
      console.warn(
        `[AnswerText Editability Check] Unknown source type: ${parentSourceType} - BLOCKED by default`
      );
      return false;
  }
};

/**
 * Get the parent Managed List's source type
 * Uses modern Xrm.WebApi async approach
 * @param {Object} formContext - Form context
 * @returns {String|null} - "Question Bank", "Custom", or null if error
 */
Ktr.ManagedListEntity.GetParentSourceType = async function (executionContext) {
  try {
    var formContext = executionContext.getFormContext();
    var managedListLookup = formContext.getAttribute("ktr_managedlist");
    if (!managedListLookup || !managedListLookup.getValue()) {
      console.warn("Managed List lookup field is empty");
      return null;
    }

    var managedListId = managedListLookup.getValue()[0].id.replace(/[{}]/g, "");

    console.log(`[Get Source Type] Querying Managed List: ${managedListId}`);

    // Use Xrm.WebApi - modern, supported, async approach
    var result = await Xrm.WebApi.retrieveRecord(
      "ktr_managedlist",
      managedListId,
      "?$select=ktr_sourcetype"
    );

    // Map option set values to readable names
    var sourceType;
    switch (result.ktr_sourcetype) {
      case 100000000:
        sourceType = "Question Bank";
        break;
      case 100000001:
        sourceType = "Custom";
        break;
      default:
        sourceType = "Unknown";
        console.warn(`Unknown source type value: ${result.ktr_sourcetype}`);
    }

    console.log(
      `[Get Source Type] Result: ${sourceType} (${result.ktr_sourcetype})`
    );
    return sourceType;
  } catch (error) {
    console.error("Error getting parent source type:", error);
    return null;
  }
};

/**
 * Check if Managed List Entity is associated with any Study that has "Approved for Launch" status
 * Uses many-to-many relationship through ktr_studymanagedlistentity intersection table
 * Checks Study Status Reason (statuscode) = 847610002 (Approved for Launch)
 * @param {Object} formContext - Form context
 * @returns {Boolean} - True if linked to approved study, false otherwise
 */
Ktr.ManagedListEntity.IsAssociatedWithApprovedStudy = async function (
  formContext
) {
  try {
    var entityId = formContext.data.entity.getId();
    if (!entityId) {
      // New record not yet saved
      console.log(
        "[Approved Study Check] New unsaved record - not in any study"
      );
      return false;
    }

    entityId = entityId.replace(/[{}]/g, "");
    console.log(`[Approved Study Check] Checking for entity: ${entityId}`);

    // Query intersection table to find associated Studies with "Approved for Launch" status
    // Study Status Reason: statuscode = 847610002 (Approved for Launch)
    var fetchXml = `
            <fetch top='1'>
                <entity name='ktr_studymanagedlistentity'>
                    <attribute name='ktr_studymanagedlistentityid' />
                    <link-entity name='kt_study' from='kt_studyid' to='ktr_study' alias='study'>
                        <attribute name='kt_studyid' />
                        <attribute name='kt_name' />
                        <attribute name='statuscode' />
                        <filter>
                            <condition attribute='statuscode' operator='eq' value='847610002' />
                        </filter>
                    </link-entity>
                    <filter>
                        <condition attribute='ktr_managedlistentity' operator='eq' value='${entityId}' />
                    </filter>
                </entity>
            </fetch>
        `.trim();

    var results = await Xrm.WebApi.retrieveMultipleRecords(
      "ktr_studymanagedlistentity",
      "?fetchXml=" + encodeURIComponent(fetchXml)
    );

    var isInApprovedStudy = results.entities.length > 0;

    if (isInApprovedStudy) {
      console.log(
        `[Approved Study Check] FOUND - Entity is in ${results.entities.length} approved study(ies)`
      );
    } else {
      console.log(
        "[Approved Study Check] NOT FOUND - Entity not in any approved study"
      );
    }

    return isInApprovedStudy;
  } catch (error) {
    console.error("Error checking approved study association:", error);
    // Fail-safe: If we can't determine, assume it's in approved study (block editing)
    console.warn(
      "[Approved Study Check] Error occurred - defaulting to BLOCKED for safety"
    );
    return true;
  }
};

/**
 * Check if parent Managed List record allows editing
 * Reads the ktr_answercodeeditable boolean field
 * Only called for CS Users and Librarians (Scripters bypass this check)
 * @param {Object} formContext - Form context
 * @returns {Boolean} - True if parent allows editing, false otherwise
 */
Ktr.ManagedListEntity.IsParentRecordEditable = async function (formContext) {
  try {
    var managedListLookup = formContext.getAttribute("ktr_managedlist");
    if (!managedListLookup || !managedListLookup.getValue()) {
      console.warn("[Parent Editability] Managed List lookup is empty");
      return false;
    }

    var managedListId = managedListLookup.getValue()[0].id.replace(/[{}]/g, "");

    console.log(`[Parent Editability] Querying parent: ${managedListId}`);

    // Retrieve parent record's editability flag
    var result = await Xrm.WebApi.retrieveRecord(
      "ktr_managedlist",
      managedListId,
      "?$select=ktr_answercodeeditable"
    );

    var isEditable = result.ktr_answercodeeditable === true;

    console.log(`[Parent Editability] Parent flag value: ${isEditable}`);
    return isEditable;
  } catch (error) {
    console.error("Error checking parent record editability:", error);
    // Fail-safe: Block editing on error
    return false;
  }
};

/**
 * Validate that Answer Code is unique within the parent Managed List
 * Called onChange of Answer Code field
 * Displays notification if duplicate found and clears the field
 * @param {Object} executionContext - Execution context from field change event
 */
Ktr.ManagedListEntity.ValidateAnswerCodeUniqueness = async function (
  executionContext
) {
  var formContext = executionContext.getFormContext();
  var answerCodeAttr = formContext.getAttribute("ktr_answercode");
  var answerCodeControl = formContext.getControl("ktr_answercode");
  var managedListAttr = formContext.getAttribute("ktr_managedlist");

  // Clear any existing notification first
  if (answerCodeControl) {
    answerCodeControl.clearNotification("DUPLICATE_ANSWER_CODE");
  }

  // Validate required fields are present
  if (!answerCodeAttr || !managedListAttr) {
    console.warn("[Uniqueness Validation] Required fields not found");
    return;
  }

  var answerCode = answerCodeAttr.getValue();
  var managedList = managedListAttr.getValue();

  // Don't validate if fields are empty
  if (!answerCode || !managedList) {
    return;
  }

  try {
    var managedListId = managedList[0].id.replace(/[{}]/g, "");
    var currentRecordId = formContext.data.entity.getId();

    // For new records, getId() returns empty string
    var recordIdFilter = "";
    if (currentRecordId) {
      currentRecordId = currentRecordId.replace(/[{}]/g, "");
      recordIdFilter = `<condition attribute='ktr_managedlistentityid' operator='ne' value='${currentRecordId}' />`;
    }

    console.log(
      `[Uniqueness Validation] Checking for duplicates of '${answerCode}' in Managed List: ${managedListId}`
    );

    // Query for duplicate Answer Codes within the same Managed List
    var fetchXml = `
            <fetch top='1'>
                <entity name='ktr_managedlistentity'>
                    <attribute name='ktr_managedlistentityid' />
                    <attribute name='ktr_answercode' />
                    <attribute name='ktr_answertext' />
                    <filter type='and'>
                        <condition attribute='ktr_managedlist' operator='eq' value='${managedListId}' />
                        <condition attribute='ktr_answercode' operator='eq' value='${answerCode}' />
                        ${recordIdFilter}
                    </filter>
                </entity>
            </fetch>
        `.trim();

    var results = await Xrm.WebApi.retrieveMultipleRecords(
      "ktr_managedlistentity",
      "?fetchXml=" + encodeURIComponent(fetchXml)
    );

    if (results.entities.length > 0) {
      // Duplicate found
      var duplicateRecord = results.entities[0];
      console.warn(
        `[Uniqueness Validation] DUPLICATE FOUND - Answer Code '${answerCode}' already exists`
      );

      // Show error notification
      if (answerCodeControl) {
        answerCodeControl.setNotification(
          `Answer Code '${answerCode}' already exists in this Managed List. Please use a unique code.`,
          "ERROR",
          "DUPLICATE_ANSWER_CODE"
        );
      }

      // Clear the invalid value
      answerCodeAttr.setValue(null);

      // Optional: Show alert for better visibility
      Xrm.Navigation.openAlertDialog({
        text: `The Answer Code '${answerCode}' is already in use.\n\nExisting record: ${
          duplicateRecord.ktr_answertext || "N/A"
        }\n\nPlease enter a unique Answer Code.`,
        title: "Duplicate Answer Code"
      });
    } else {
      console.log(
        `[Uniqueness Validation] VALID - Answer Code '${answerCode}' is unique`
      );
    }
  } catch (error) {
    console.error("Error validating answer code uniqueness:", error);
    // Don't block the user on validation errors, just log
  }
};

/**
 * Check if managed list is ever in snapshot
 * Reads the ktr_everinsnapshot boolean field
 * Only called for CS Users and Librarians (Scripters bypass this check)
 * @param {Object} formContext - Form context
 * @returns {Boolean} - True if the managed list is ever in snapshot, false otherwise
 */
Ktr.ManagedListEntity.IsEverInSnapshot = async function (formContext) {
  try {
    var everinsnapshot = formContext.getAttribute("ktr_everinsnapshot");

    if (!everinsnapshot || !everinsnapshot.getValue()) {
      console.warn("EverInSnapshot is empty");
      return false;
    }
    var status = everinsnapshot.getValue();
    console.log(`ktr_everinsnapshot flag value: ${status}`);
    return status;
  } catch (error) {
    console.error("Error checking everinsnapshot:", error);
    // Fail-safe: Block editing on error
    return false;
  }
};

/**
 * ============================================================================
 * EVENT HANDLERS - MANAGED LIST ENTITY FORM
 * Register these functions in Managed List Entity Form Properties > Events
 * ============================================================================
 */

/**
 * Form OnLoad Event Handler
 * Evaluates Answer Code editability when form opens based on user role
 * @param {Object} executionContext - Pass execution context as first parameter
 */
Ktr.ManagedListEntity.OnFormLoad = async function (executionContext) {
  console.log(
    "[Event] Form Load - Initializing Answer Code Editability with Role-Based Logic"
  );
  // Get current user's role type
  var userRoleType = Ktr.ManagedListEntity.GetUserRoleType();
  console.log(`[User Role] Detected role type: ${userRoleType}`);

  // Get parent Managed List source type
  var parentSourceType =
    await Ktr.ManagedListEntity.GetParentSourceType(executionContext);

  Ktr.ManagedListEntity.SetAnswerCodeEditability(
    executionContext,
    userRoleType,
    parentSourceType
  );
  Ktr.ManagedListEntity.SetAnswerTextEditability(
    executionContext,
    userRoleType,
    parentSourceType
  );
};

/**
 * Answer Code Field OnChange Event Handler
 * Validates uniqueness when user enters/changes answer code
 * @param {Object} executionContext - Pass execution context as first parameter
 */
Ktr.ManagedListEntity.OnAnswerCodeChange = function (executionContext) {
  console.log("[Event] Answer Code Changed - Validating Uniqueness");
  Ktr.ManagedListEntity.ValidateAnswerCodeUniqueness(executionContext);
};
