/**
 * @file        009-projectAddModulesButton.js
 * @description add modules to a project
 *
 * @date        2025-07-31
 * @version     1.2
 *
/**
 * @file        009-projectAddModulesButton.js
 * @description add modules to a project
 *
 * @date        2025-07-31
 * @version     1.2
 *
 * @usage       This script is invoked when click in a custom button in a Project form (in edit-mode) to add modules to the question.
 * @notes       This script uses Xrm Power Apps library
 */

let Sdk = window.Sdk || {};

/**
 * Request to execute a create operation
 */
Sdk.CreateRequest = class {
    constructor(entityName, payload) {
        this.etn = entityName;
        this.payload = payload;
    }
    getMetadata() {
        return {
            boundParameter: null,
            parameterTypes: {},
            operationType: 2, // This is a CRUD operation. Use '0' for actions and '1' for functions
            operationName: "Create"
        };
    }
};

var projectAddModulesButton = (function (config) {
    const lookupTableName = config.lookupTableName;
    const tableQuestionProperties = config.tableQuestionProperties;

    function main(primaryControl) {
        const formContext = primaryControl;
        const projectId = formContext.data.entity.getId().replace(/[{}]/g, "");
        refreshGrid();
        openSearchDialog()
            .then(async function (selectedModuleRecords) {
                if (selectedModuleRecords.length > 0) {
                    let entities = await retrieveRecords(selectedModuleRecords);
                    return entities;
                }
            })
            .then(async function (entities) {
                if (entities) {
                    await copyQuestions(entities, projectId);
                }
            })
            .then(function () {
                refreshGrid();
            })
            .catch(function (error) {
                Xrm.Navigation.openAlertDialog({
                    text: "Error: " + error.message
                });
            });
    }

    async function openSearchDialog() {
        const STATECODE_ACTIVE = 0;
        const STATUSCODE_ACTIVE = 1;

        const projectId = Xrm.Page.data.entity.getId().replace(/[{}]/g, "");

        const existingModules = await Xrm.WebApi.online
            .retrieveMultipleRecords(
                "kt_questionnairelines",
                `?$filter=_ktr_project_value eq ${projectId} and statecode eq ${STATECODE_ACTIVE} and statuscode eq ${STATUSCODE_ACTIVE}&$select=_ktr_module_value`
            )
            .then((response) => {
                return response.entities
                    .map((e) => e._ktr_module_value)
                    .filter((id) => id);
            })
            .catch((error) => {
                console.error("Error retrieving existing modules:", error);
                return [];
            });

        let filterXml = `<filter type="and">
                        <condition attribute="statecode" operator="eq" value="${STATECODE_ACTIVE}" /> 
                        <condition attribute="statuscode" operator="eq" value="${STATUSCODE_ACTIVE}" />`;

        if (existingModules.length > 0) {
            existingModules.forEach((id) => {
                filterXml += `<condition attribute="kt_moduleid" operator="ne" value="${id}" />`;
            });
        }

        filterXml += `</filter>`;

        let lookupOptions = {
            defaultEntityType: lookupTableName,
            entityTypes: [lookupTableName],
            allowMultiSelect: true,
            disableMru: true,
            filters: [{ filterXml: filterXml }]
        };

        return Xrm.Utility.lookupObjects(lookupOptions);
    }

    async function retrieveRecords(selectedModuleRecords) {
        const moduleIdFilter = selectedModuleRecords
            .map((module) => `_ktr_module_value eq ${module.id.replace(/[{}]/g, "")}`)
            .join(" or ");

        const isActiveFilter = " and statecode eq 0"

        const query = `?$filter=${encodeURIComponent("("+moduleIdFilter+")"+isActiveFilter)}
    &$select=ktr_name,_ktr_module_value,ktr_sortorder
    &$expand=ktr_QuestionBank($select=${Object.values(
            tableQuestionProperties
        ).join(",")})`;

        return Xrm.WebApi.online
            .retrieveMultipleRecords("ktr_modulequestionbank", query)
            .then(function (response) {
                let duplicates = validDuplicates(response.entities);

                if (duplicates.length > 0) {
                    let duplicateMessages = duplicates.map((d) => {
                        let moduleName =
                            d["_ktr_module_value@OData.Community.Display.V1.FormattedValue"];
                        let questionTitle = d.ktr_QuestionBank.kt_questiontitle;
                        return `[${moduleName}] - ${questionTitle}`;
                    });

                    throw new Error(
                        `Duplicated questions found:\n${duplicateMessages.join("\n")}`
                    );
                }

                return response.entities;
            });
    }


    async function copyQuestions(entities, projectId) {
        let lastPosition = await getLastQuestionPosition(projectId) || 0;
        let results = [];

        //Group by module
        const groupedByModule = entities.reduce((acc, record) => {
            const moduleId = record._ktr_module_value;
            if (!acc[moduleId]) acc[moduleId] = [];
            acc[moduleId].push(record);
            return acc;
        }, {});

        // Process one module at a time
        const sortedModuleIds = Object.keys(groupedByModule);

        for (let moduleId of sortedModuleIds) {
            const moduleRecords = groupedByModule[moduleId];

            // Sort each module's questions by ktr_sortorder
            moduleRecords.sort((a, b) => {
                const orderA = a.ktr_sortorder ?? 0;
                const orderB = b.ktr_sortorder ?? 0;
                return orderA - orderB;
            });

            for (let i = 0; i < moduleRecords.length; i++) {
                const record = moduleRecords[i];
                const newSortOrder = ++lastPosition;

                try {
                    const questionLine = {
                        ["ktr_Module@odata.bind"]: `/kt_modules(${record._ktr_module_value})`,
                        statecode: record.ktr_QuestionBank.statecode,
                        kt_standardorcustom: record.ktr_QuestionBank.kt_standardorcustom,
                        kt_questionvariablename: record.ktr_QuestionBank.kt_name,
                        kt_questiontitle: record.ktr_QuestionBank.kt_questiontitle,
                        kt_questiontype: record.ktr_QuestionBank.kt_questiontype,
                        ktr_questionversion: record.ktr_QuestionBank.kt_questionversion,
                        kt_questiontext2: record.ktr_QuestionBank.kt_defaultquestiontext,
                        ktr_answerlist: record.ktr_QuestionBank.ktr_answerlist,
                        kt_questionsortorder: newSortOrder,
                        ["ktr_Project@odata.bind"]: `/kt_projects(${projectId})`,
                        ktr_questionrationale: record.ktr_QuestionBank.kt_questionrationale,
                        ktr_scripternotes: record.ktr_QuestionBank.ktr_scripternotes,
                        ktr_rowsortorder: record.ktr_QuestionBank.ktr_rowsortorder,
                        ktr_columnsortorder: record.ktr_QuestionBank.ktr_columnsortorder,
                        ktr_answermin: record.ktr_QuestionBank.ktr_answermin,
                        ktr_answermax: record.ktr_QuestionBank.ktr_answermax,
                        ktr_questionformatdetails: record.ktr_QuestionBank.ktr_questionformatdetails,
                        ktr_customnotes: record.ktr_QuestionBank.ktr_customnotes,
                        ktr_isdummyquestion: record.ktr_QuestionBank.kt_isdummyquestion
                    };

                    const result = await Xrm.WebApi.createRecord("kt_questionnairelines", questionLine);
                    await copyAnswerList(record.ktr_QuestionBank.kt_questionbankid, result.id);

                    results.push({ id: result.id, success: true });
                } catch (error) {
                    console.error("Error creating question line:", error.message);
                    results.push({ success: false, error: error.message });
                }
            }
        }

        return results;
    }


    async function copyAnswerList(questionBankId, questionnaireLineId) {

        var answers = await Xrm.WebApi.online.retrieveMultipleRecords(
            "ktr_questionanswerlist",
            `?$filter=_ktr_kt_questionbank_value eq ${questionBankId}&$select=ktr_name,ktr_answerid,ktr_customproperty,ktr_displayorder,ktr_effectivedate,ktr_enddate,ktr_isactive,ktr_isexclusive,ktr_answertext,ktr_answertype,ktr_isopen,ktr_isfixed,ktr_istranslatable,statecode,statuscode,ktr_version`
        );
        let createRequests = [];

        if (answers.entities && answers.entities.length > 0) {
            let createRequests = answers.entities.map((answerRecord) => {
                return new Sdk.CreateRequest("ktr_questionnairelinesanswerlist", {
                    ktr_name: answerRecord.ktr_name,
                    ktr_answercode: answerRecord.ktr_name,
                    ktr_answerid: answerRecord.ktr_answerid,
                    ktr_answertype: answerRecord.ktr_answertype,
                    ktr_customproperty: answerRecord.ktr_customproperty,
                    ktr_displayorder: answerRecord.ktr_displayorder,
                    ktr_effectivedate: answerRecord.ktr_effectivedate,
                    ktr_enddate: answerRecord.ktr_enddate,
                    ktr_isactive: answerRecord.ktr_isactive,
                    ktr_isexclusive: answerRecord.ktr_isexclusive,
                    ktr_answertext: answerRecord.ktr_answertext,
                    ktr_isopen: answerRecord.ktr_isopen,
                    ktr_isfixed: answerRecord.ktr_isfixed,
                    ktr_istranslatable: answerRecord.ktr_istranslatable,
                    statecode: answerRecord.statecode,
                    statuscode: answerRecord.statuscode,
                    ktr_version: answerRecord.ktr_version,
                    ["ktr_QuestionnaireLine@odata.bind"]: "/kt_questionnairelineses(" + questionnaireLineId + ")",
                    ["ktr_QuestionBank@odata.bind"]: "/kt_questionbanks(" + questionBankId + ")",
                    ["ktr_QuestionAnswer@odata.bind"]: "/ktr_questionanswerlists(" + answerRecord.ktr_questionanswerlistid + ")"

                });
            })

            return await Xrm.WebApi.online
                .executeMultiple(createRequests)
                .then(function (response) {

                })
                .catch(function (error) {
                    Xrm.Navigation.openAlertDialog({
                        text: "Error creating: " + error.message
                    });
                });
        }

        else {
            console.log(
                "No answer records found for the selected Question Bank."
            );
        }
    }
    function validDuplicates(arr) {
        const seen = new Map();
        const duplicates = [];
        arr.forEach((obj) => {
            const key = obj.ktr_QuestionBank.kt_questionbankid;

            if (seen.has(key)) {
                if (!seen.get(key).isDuplicate) {
                    duplicates.push(seen.get(key).object);
                    seen.get(key).isDuplicate = true;
                }
                duplicates.push(obj);
            } else {
                seen.set(key, { object: obj, isDuplicate: false });
            }
        });

        return duplicates;
    }

    function refreshGrid() {
        let subgridControl = Xrm.Page.getControl("Subgrid_new_1");
        if (subgridControl) {
            subgridControl.refresh();
        } else {
            console.error("Subgrid not found on the form.");
        }
    }

    async function getLastQuestionPosition(parentQuestionId) {
        let fetchXmlQuery = `?$apply=filter((_ktr_project_value eq ${parentQuestionId} and statecode eq 0))/aggregate(kt_questionsortorder with max as MaxVersion)`;

        return Xrm.WebApi.online
            .retrieveMultipleRecords("kt_questionnairelines", fetchXmlQuery)
            .then(
                function success(result) {
                    return result.entities[0]?.MaxVersion ?? 0;
                },
                function error(error) {
                    console.log("Error retrieving records:", error.message);
                }
            );
    }

    return {
        main: main
    };
})({
    lookupTableName: "kt_module",
    tableQuestionProperties: {
        statecode: "statecode",
        statuscode: "statuscode",
        questionversion: "kt_questionversion",
        questiontype: "kt_questiontype",
        defaultquestiontext: "kt_defaultquestiontext",
        answerlist: "ktr_answerlist",
        questionrationale: "kt_questionrationale",
        standardorcustom: "kt_standardorcustom",
        questiontitle: "kt_questiontitle",
        scripternotes: "ktr_scripternotes",
        singleormulticode: "kt_singleormulticode",
        methodology: "kt_methodology",
        name: "kt_name",
        rowsortorder: "ktr_rowsortorder",
        columnsortorder: "ktr_columnsortorder",
        answermin: "ktr_answermin",
        answermax: "ktr_answermax",
        questionformatdetails: "ktr_questionformatdetails",
        customnotes: "ktr_customnotes",
        isdummyquestion: "kt_isdummyquestion"
    }
});
    function refreshGrid() {
