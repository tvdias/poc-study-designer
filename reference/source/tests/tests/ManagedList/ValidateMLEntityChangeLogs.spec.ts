import { expect, mergeTests } from '@playwright/test';
import { logintest } from '../Fixture/LoginFixture';
import { createproject } from '../Fixture/CreateProjectWithStdQue';
import { Utils } from "../../utils/utils";
import { DropDownList } from '../../constants/DropDownList.json';
import { WebHelper } from '../../utils/WebHelper';
import { CommonTestData } from '../../Test Data/CommonTestData.json';
import { Questionnaire } from '../../selectors/QuestionnaireSelector.json';
import { Questionnaireservice } from '../../services/QuestionnaireService';
import { TestData } from '../../Test Data/QuestionnnaireData.json';
import { ProjectService } from '../../services/ProjectService';
import { ManagedListService } from '../../services/ManagedListService';
import { TestData as MLTestData } from '../../Test Data/ManagedListData.json';
import { ManagedList } from '../../selectors/ManagedListSelectors.json';
import { StudyTestData } from '../../Test Data/StudyData.json';
import { StudyService } from '../../services/StudyService';


// Using a LoginFixture and CreateProjectWithStdQue to handle setup and teardown for all test cases:
// 1. Login the application with CS user
// 2. Create the project and add a question before each test execution.
// 3. Delete the project after the each test case execution

let managedListName = "";
let questionName = "";
let studyName = "";
let newStudyVersionName = "";

// Merges the results of the login test and the create a Project test into a single combined test execution.
const test = mergeTests(logintest, createproject);


//  Executes setup steps before each test case to prepare the required environment.

test.beforeEach(async ({ page,loginPage,projectName,guid }) => {
    const webHelper = new WebHelper(page);
    const questionnaireService = new Questionnaireservice(page);
    const projectService = new ProjectService(page);
    const managedListService = new ManagedListService(page);
    const studyService = new StudyService(page);

    questionName = CommonTestData.QuestionVariableName + Utils.generateText();
    managedListName = MLTestData.ManagedListName + Utils.generateText();
    studyName = StudyTestData.StudyName + Utils.generateGUID();
    newStudyVersionName = studyName + '_New Version2';

    await test.step('Create and verify the Manage list from Project', async () => {
        await managedListService.create(managedListName);
        await managedListService.verifyAddedManagedListDetails(managedListName, MLTestData.IsAutoGenerated_No);
        await managedListService.selectTheManagedList(managedListName);
    });
    await test.step('associate the added question from project to ML', async () => {
        await managedListService.addQuestion(managedListName, "");
        await managedListService.verifyAddedQuestionDetails(TestData.StandardQuest_VariableName1, MLTestData.Location, projectName);
        await webHelper.saveRecord();
    });

    await test.step('Go to Entities tab and Click on the New ML Entity button', async () => {
        await questionnaireService.navigateToTheTab(ManagedList.Tabs.Entities);
        await managedListService.clickOnNewManagedListEntityButton();
        await managedListService.verifyQuickCreateWindow();
    });
    await test.step('Verify that Answer Text field is mandatory and it is text field that is shown on screen to respondents', async () => {
        await managedListService.verifyAnswerTextIsEditableMandatory();
    });
    await test.step('Verify that ML field is automatically populated', async () => {
        await managedListService.verifyManagedListAutoPopulated(managedListName);
    });
    await test.step('Enter Answer Text', async () => {
        await managedListService.fillAnswerText(TestData.AnswerText);
        await webHelper.saveAndCloseQuickCreateRecord();
        await webHelper.verifySaveButton();
        await webHelper.saveAndCloseRecord();
    });
    await test.step('Create a Draft study ', async () => {
        await projectService.addScripterUserToProject();
        await studyService.CreateNewStudy(studyName, StudyTestData.Category, StudyTestData.FieldWorkMarket,
            StudyTestData.MaconomyJobNumber, StudyTestData.ProjectOperationsURL, StudyTestData.ScripterNotes);
        await webHelper.handleConfirmationPopup();
        await studyService.ValidateInitialDraftStateStudy();
    });

    await test.step('Update study from Draft to Ready for Scritping', async () => {
        await studyService.updateStudyStatus(DropDownList.Status.ReadyForScripting);
        await webHelper.saveRecord();
        await webHelper.verifyNewButton();
        await webHelper.clickGoBackArrow();
    });
    await test.step('Navigate to Manage List and open ML', async () => {
        await questionnaireService.navigateToTheTab(ManagedList.Tabs.ManagedList);
        await managedListService.selectTheManagedList(managedListName);

    });

});


test("[2548012] Verify that when Manage List entities are added, the change log is generated.", { tag: ['@Regression', '@MLEntity'] }, async ({ page, browser,loginPage,projectName,guid }) => {

    test.info().annotations.push({ type: 'TestCaseId', description: '2548012' });
    const webHelper = new WebHelper(page);
    const questionnaireService = new Questionnaireservice(page);
    const managedListService = new ManagedListService(page);
    const studyService = new StudyService(page);


    await test.step('On the Manage List, navigate to Entities tab and add new Manage List Entity', async () => {
        await questionnaireService.navigateToTheTab(ManagedList.Tabs.Entities);
        await managedListService.clickOnNewManagedListEntityButton();
        await managedListService.verifyQuickCreateWindow();
        await managedListService.fillAnswerText(TestData.AnswerText1);
        await webHelper.saveAndCloseQuickCreateRecord();
        await webHelper.verifySaveButton();
        await webHelper.saveAndCloseRecord();
    });


    await test.step('Create new version of the Study and move it to Ready for Scripting', async () => {
        await studyService.openStudy(studyName);
        await studyService.createNewStudyVersion(newStudyVersionName);
        await webHelper.saveRecord();
        await studyService.updateStudyStatus(DropDownList.Status.ReadyForScripting);

    });
    await test.step('Verify that when Manage List entities are added, the change log is generated', async () => {
        const addEntity = Questionnaire.Text.CAT_INTRO + ',' + 'Field Change (Managed List Entity)';
        const changeLogs: string[] = [addEntity]
        await studyService.validateStudyChangeLogs(changeLogs);
    });

});

test("[2548014] Verify that when Manage List entities are deactivated, the change log is generated.", { tag: ['@Regression', '@MLEntity'] }, async ({ page, browser,loginPage,projectName,guid }) => {
    test.info().annotations.push({ type: 'TestCaseId', description: '2548014' });

    const webHelper = new WebHelper(page);
    const questionnaireService = new Questionnaireservice(page);
    const studyService = new StudyService(page);
    const managedListService = new ManagedListService(page);

    await test.step('On the Manage List, navigate to Entities tab and remove one of the entities', async () => {
        await questionnaireService.navigateToTheTab(ManagedList.Tabs.Entities);
        //add one more ML and deactivate it as Steve adviced -> changing the steps 
        await managedListService.clickOnNewManagedListEntityButton();
        await managedListService.verifyQuickCreateWindow();
        await managedListService.fillAnswerText(TestData.AnswerText);
        await webHelper.saveAndCloseQuickCreateRecord();
        
        await questionnaireService.deactivateTheAnswer();
        await page.goBack(); 
        await webHelper.verifySaveButton();
        await webHelper.saveAndCloseRecord(); 
        await webHelper.saveAndCloseRecord(); 
    });


    await test.step('Create new version of the Study and move it to Ready for Scripting', async () => {
        await studyService.openStudy(studyName);
        await studyService.createNewStudyVersion(newStudyVersionName);
        await webHelper.saveRecord();
        await studyService.updateStudyStatus(DropDownList.Status.ReadyForScripting);

    });
    await test.step('Verify that when Manage List entities are added, the change log is generated', async () => {
        const addEntity = Questionnaire.Text.CAT_INTRO + ',' + 'Managed List Entity removed';
        const changeLogs: string[] = [addEntity]
        await studyService.validateStudyChangeLogs(changeLogs);
    });


});

test("[2548016] Verify that when Manage List entitie's Answer text is modified, the change log is generated.", { tag: ['@Regression', '@MLEntity'] }, async ({ page, browser,loginPage,projectName,guid }) => {

    test.info().annotations.push({ type: 'TestCaseId', description: '2548016' });
    const webHelper = new WebHelper(page);
    const questionnaireService = new Questionnaireservice(page);
    const studyService = new StudyService(page);


    await test.step('On the Manage List, navigate to Entities tab and add new Manage List Entity', async () => {
        await questionnaireService.navigateToTheTab(ManagedList.Tabs.Entities);
        await questionnaireService.clickOnAnswerText();
        await questionnaireService.updateAnswerText(TestData.AnswerText1);
        await webHelper.verifySaveButton();
        await webHelper.saveAndCloseRecord();
    });


    await test.step('Create new version of the Study and move it to Ready for Scripting', async () => {
        await studyService.openStudy(studyName);
        await studyService.createNewStudyVersion(newStudyVersionName);
        await webHelper.saveRecord();
        await studyService.updateStudyStatus(DropDownList.Status.ReadyForScripting);

    });
    await test.step('Verify that when Manage List entities are added, the change log is generated', async () => {
        const addEntity = Questionnaire.Text.CAT_INTRO + ',' + 'Field Change (Managed List Entity)';
        const changeLogs: string[] = [addEntity]
        await studyService.validateStudyChangeLogs(changeLogs);
    });
    
});

